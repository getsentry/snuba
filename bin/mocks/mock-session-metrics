#!/usr/bin/env python
import socket
from concurrent.futures import ThreadPoolExecutor

from confluent_kafka import Producer

conf = {"bootstrap.servers": "localhost:9092", "client.id": socket.gethostname()}

count = 0


def go(thread: int) -> None:
    producer = Producer(conf)

    def acked(err, msg) -> None:
        if err is not None:
            print("Failed to deliver message: %s: %s" % (str(msg), str(err)))
        else:
            if msg.offset() % 50 == 0:
                print(f"Thread {thread}. Message produced: offset {msg.offset()}")

    for i in range(0, 20):
        if i % 500 == 0:
            print(f"Thread {thread}. MSG {i}")
            producer.poll(0.1)
        v = f'{{ "org_id": 1, "project_id": 2, "metric_id": {int(i%70)}, "tags": {{"2": {3}, "4": {5}}}, "unit": "ms", "value": [36, 49, 57, 68], "type": "d", "timestamp": 1644127962, "retention_days": 90}}'
        producer.produce("snuba-metrics", value=v.encode("utf-8"), callback=acked)

    producer.flush()


with ThreadPoolExecutor(max_workers=4) as executor:
    future = executor.submit(go, 0)
    future2 = executor.submit(go, 1)
    print(future.result())
    print(future2.result())
