version: v1
kind: entity
name: eap_spans_rpc

schema:
  [
    { name: service, type: String },
    { name: span_id, type: UInt, args: { size: 64 } },
    { name: parent_span_id, type: UInt, args: { size: 64 } },
    { name: segment_id, type: UInt, args: { size: 64 } },
    { name: segment_name, type: String },
    { name: is_segment, type: UInt, args: { size: 8 } },
    { name: start_timestamp, type: DateTime64, args: { precision: 6 } },
    { name: end_timestamp, type: DateTime64, args: { precision: 6 } },
    { name: duration_ms, type: Float, args: { size: 64 } },
    { name: exclusive_time_ms, type: Float, args: { size: 64 } },
    { name: name, type: String },

    # these are the required columns for an 'RPC entity' that can be used by EAP RPCs
    { name: trace_id, type: UUID },
    { name: organization_id, type: UInt, args: { size: 64 } },
    { name: project_id, type: UInt, args: { size: 64 } },
    { name: time, type: DateTime }, # used by TimeSeriesProcessor
    { name: timestamp, type: DateTime }, # mapped to _sort_timestamp
    { name: retention_days, type: UInt, args: { size: 16 } },
    { name: sampling_factor, type: Float, args: { size: 64 } },
    { name: sampling_weight, type: UInt, args: { size: 64 } },
    { name: sign, type: Int, args: { size: 8 } },
    { name: attr_str, type: Map, args: { key: { type: String }, value: { type: String } } },
    { name: attr_f64, type: Map, args: { key: { type: String }, value: { type: Float, args: { size: 64 } } } },
    { name: attr_i64, type: Map, args: { key: { type: String }, value: { type: Int, args: { size: 64 } } } },
  ]

storages:
  - storage: eap_spans
    is_writable: true
    translation_mappers:
      columns:
        - mapper: ColumnToColumn
          args:
            from_table_name: null
            from_col_name: timestamp
            to_table_name: null
            to_col_name: _sort_timestamp

storage_selector:
  selector: DefaultQueryStorageSelector

query_processors:
  # a processor that creates a virtual 'time' column to group by for generating timeseries.
  - processor: TimeSeriesProcessor
    args:
      time_group_columns:
        time: timestamp
      time_parse_columns:
        - start_timestamp
        - end_timestamp
  # maps (e.g.) attr_str[sentry.name] to the clickhouse column 'name'
  - processor: EAPClickhouseColumnRemapper
    args:
      hash_bucket_name: attr_str
      data_type: String
      keys:
        sentry.name: name
        sentry.service: service
        sentry.parent_span_id: parent_span_id
        sentry.segment_name: segment_name
        sentry.start_timestamp: start_timestamp
        sentry.end_timestamp: end_timestamp
        sentry.timestamp: timestamp
  # maps attr_str[span_id] to hex(span_id)
  - processor: EAPClickhouseColumnRemapper
    args:
      hash_bucket_name: attr_str
      data_type: hex
      keys:
        sentry.span_id: span_id
        sentry.segment_id: segment_id
  # maps attr_f64[duration_ms] to CAST(duration_ms, Float64)
  - processor: EAPClickhouseColumnRemapper
    args:
      hash_bucket_name: attr_f64
      data_type: Float64
      keys:
        sentry.exclusive_time_ms: exclusive_time_ms
        sentry.duration_ms: duration_ms
  # maps attr_i64[project_id] to CAST(project_id, Int64)
  - processor: EAPClickhouseColumnRemapper
    args:
      hash_bucket_name: attr_i64
      data_type: Int64
      keys:
        sentry.exclusive_time_micro: exclusive_time_micro
        sentry.duration_micro: duration_micro
        sentry.organization_id: organization_id
        sentry.project_id: project_id
  # maps avg(attr_i64[hello]) to avgIf(attr_i64['hello'], mapContains(attr_i64, 'hello'))
  - processor: OptionalAttributeAggregationTransformer
    args:
      attribute_column_names:
        - attr_f64
        - attr_i64
      aggregation_names:
        - count
        - avg
        - avgWeighted
        - max
        - min
        - uniq
      curried_aggregation_names:
        - quantile
        - quantileTDigestWeighted
  # maps a few things:
  # - attr_i64['blah'] to CAST(arrayIndex(attr_num_5, 'blah'), 'Int64')
  # - mapContains(attr_str, blah) to mapContains(attr_str_5, blah)
  # - mapKeys(attr_str) to arrayConcat(mapKeys(attr_str_0), mapKeys(attr_str_1), ...)
  # - mapValues(attr_str) to arrayConcat(mapValues(attr_str_0), mapValues(attr_str_1), ...)
  - processor: EAPMapSharder
    args:
      src_bucket_name: attr_str
      dest_bucket_name: attr_str
      data_type: String
  - processor: EAPMapSharder
    args:
      src_bucket_name: attr_f64
      dest_bucket_name: attr_num
      data_type: Float64
  - processor: EAPMapSharder
    args:
      src_bucket_name: attr_i64
      dest_bucket_name: attr_num
      data_type: Int64

validate_data_model: do_nothing # in order to reference aliased columns, we shouldn't validate columns purely based on the entity schema
validators:
  - validator: EntityRequiredColumnValidator
    args:
      required_filter_columns: [organization_id]

required_time_column: timestamp
